<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>PKR DASC stacked keogram 2025-09</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background: #111;
      color: #eee;
      margin: 0;
      padding: 1rem;
    }
    h1 {
      margin-top: 0;
    }
    #container {
      position: relative;
      display: inline-block;
      border: 1px solid #444;
    }
    #keogram {
      max-width: 100%;
      height: auto;
      display: block;
      cursor: crosshair;
    }
    #info {
      margin-top: 0.75rem;
      font-size: 0.9rem;
      color: #ccc;
      white-space: pre-line;
    }
    #info strong {
      color: #fff;
    }
    #hover-tooltip {
        position: absolute;
        padding: 2px 6px;
        font-size: 12px;
        background: rgba(0, 0, 0, 0.85);
        color: #fff;
        border-radius: 3px;
        pointer-events: none;
        opacity: 0;
        transform: translate(8px, 8px); /* small offset from cursor */
        transition: opacity 0.05s linear;
        z-index: 20;
    }

  </style>
</head>
<body>
  <h1>PKR stacked keogram – September 2025</h1>
  <p>Click anywhere on the stacked keogram to open the corresponding all-sky movie ~15 minutes before that time (UT).</p>

  <div id="keogram-container" style="position: relative; display: inline-block;">
    <img
      id="keogram"
      src="stacked_keograms_202509.png"
      alt="PKR DASC stacked keogram"
    >
    <canvas
      id="keogram-overlay"
      style="position: absolute; top: 0; left: 0; pointer-events: none;"
    ></canvas>
  </div>

  <div id="hover-tooltip"></div>

  <div id="info">
    Click on the image to select a day and time.
  </div>

  <video id="player" style="display:none;"></video>

  <script>
    const YEAR = 2025;
    const MONTH = 9;

    // JSON files should be in the same folder as this HTML.
    const keogramMeta = {
  "year": 2025,
  "month": 9,
  "days": [
    {
      "ymd": "20250904",
      "day": 4,
      "h0": 5.0,
      "h1": 14.0,
      "has_video": false
    },
    {
      "ymd": "20250905",
      "day": 5,
      "h0": 5.0,
      "h1": 14.0,
      "has_video": false
    },
    {
      "ymd": "20250906",
      "day": 6,
      "h0": 5.0,
      "h1": 13.0,
      "has_video": false
    },
    {
      "ymd": "20250908",
      "day": 8,
      "h0": 5.0,
      "h1": 15.0,
      "has_video": false
    },
    {
      "ymd": "20250909",
      "day": 9,
      "h0": 5.0,
      "h1": 15.0,
      "has_video": false
    },
    {
      "ymd": "20250910",
      "day": 10,
      "h0": 5.0,
      "h1": 15.0,
      "has_video": false
    },
    {
      "ymd": "20250911",
      "day": 11,
      "h0": 5.0,
      "h1": 15.0,
      "has_video": false
    },
    {
      "ymd": "20250912",
      "day": 12,
      "h0": 5.0,
      "h1": 15.0,
      "has_video": true
    },
    {
      "ymd": "20250914",
      "day": 14,
      "h0": 5.0,
      "h1": 15.0,
      "has_video": true
    },
    {
      "ymd": "20250915",
      "day": 15,
      "h0": 5.0,
      "h1": 15.0,
      "has_video": true
    },
    {
      "ymd": "20250916",
      "day": 16,
      "h0": 5.0,
      "h1": 15.0,
      "has_video": true
    },
    {
      "ymd": "20250917",
      "day": 17,
      "h0": 4.0,
      "h1": 15.0,
      "has_video": true
    },
    {
      "ymd": "20250918",
      "day": 18,
      "h0": 4.0,
      "h1": 15.0,
      "has_video": false
    },
    {
      "ymd": "20250919",
      "day": 19,
      "h0": 4.0,
      "h1": 15.0,
      "has_video": false
    },
    {
      "ymd": "20250920",
      "day": 20,
      "h0": 4.0,
      "h1": 15.0,
      "has_video": false
    },
    {
      "ymd": "20250921",
      "day": 21,
      "h0": 4.0,
      "h1": 15.0,
      "has_video": false
    },
    {
      "ymd": "20250922",
      "day": 22,
      "h0": 4.0,
      "h1": 15.0,
      "has_video": false
    },
    {
      "ymd": "20250923",
      "day": 23,
      "h0": 4.0,
      "h1": 15.0,
      "has_video": false
    },
    {
      "ymd": "20250924",
      "day": 24,
      "h0": 4.0,
      "h1": 15.0,
      "has_video": false
    },
    {
      "ymd": "20250925",
      "day": 25,
      "h0": 4.0,
      "h1": 10.0,
      "has_video": false
    },
    {
      "ymd": "20250926",
      "day": 26,
      "h0": 4.0,
      "h1": 16.0,
      "has_video": false
    },
    {
      "ymd": "20250927",
      "day": 27,
      "h0": 4.0,
      "h1": 16.0,
      "has_video": true
    },
    {
      "ymd": "20250928",
      "day": 28,
      "h0": 4.0,
      "h1": 16.0,
      "has_video": true
    },
    {
      "ymd": "20250929",
      "day": 29,
      "h0": 4.0,
      "h1": 16.0,
      "has_video": true
    },
    {
      "ymd": "20250930",
      "day": 30,
      "h0": 4.0,
      "h1": 16.0,
      "has_video": true
    }
  ],
  "global_min_hour": 4.0,
  "global_max_hour": 16.0
}

    const videoMeta = {
  "year": 2025,
  "month": 9,
  "videos": [
    {
      "ymd": "20250912",
      "video_file": "PKR_DASC_20250912_rgb_512.mp4",
      "start_utc": "2025-09-12T05:15:52Z",
      "end_utc": "2025-09-12T14:17:13Z"
    },
    {
      "ymd": "20250914",
      "video_file": "PKR_DASC_20250914_rgb_512.mp4",
      "start_utc": "2025-09-14T05:08:00Z",
      "end_utc": "2025-09-14T14:23:48Z"
    },
    {
      "ymd": "20250915",
      "video_file": "PKR_DASC_20250915_rgb_512.mp4",
      "start_utc": "2025-09-15T05:04:06Z",
      "end_utc": "2025-09-15T14:26:58Z"
    },
    {
      "ymd": "20250916",
      "video_file": "PKR_DASC_20250916_rgb_512.mp4",
      "start_utc": "2025-09-16T05:00:12Z",
      "end_utc": "2025-09-16T14:30:11Z"
    },
    {
      "ymd": "20250917",
      "video_file": "PKR_DASC_20250917_rgb_512.mp4",
      "start_utc": "2025-09-17T04:56:19Z",
      "end_utc": "2025-09-17T14:33:18Z"
    },
    {
      "ymd": "20250927",
      "video_file": "PKR_DASC_20250927_rgb_512.mp4",
      "start_utc": "2025-09-27T04:18:21Z",
      "end_utc": "2025-09-27T15:04:29Z"
    },
    {
      "ymd": "20250928",
      "video_file": "PKR_DASC_20250928_rgb_512.mp4",
      "start_utc": "2025-09-28T04:14:37Z",
      "end_utc": "2025-09-28T15:07:25Z"
    },
    {
      "ymd": "20250929",
      "video_file": "PKR_DASC_20250929_rgb_512.mp4",
      "start_utc": "2025-09-29T04:10:56Z",
      "end_utc": "2025-09-29T15:10:32Z"
    },
    {
      "ymd": "20250930",
      "video_file": "PKR_DASC_20250930_rgb_512.mp4",
      "start_utc": "2025-09-30T04:07:13Z",
      "end_utc": "2025-09-30T15:13:36Z"
    }
  ]
}

    const videoBase = "https://optics.gi.alaska.edu/realtime/data/MPEG/PKR_DASC_512/";

    const img       = document.getElementById("keogram");
    const overlay   = document.getElementById("keogram-overlay");
    const container = document.getElementById("keogram-container");
    const infoBox   = document.getElementById("info");
    const tooltip   = document.getElementById("hover-tooltip");

    function init() {
      const img       = document.getElementById("keogram");
      const infoBox   = document.getElementById("info");
      const tooltip   = document.getElementById("hover-tooltip");
      const player    = document.getElementById("player");

      if (!img || !infoBox || !tooltip || !player) {
        console.error("Missing DOM elements needed for init().");
        return;
      }

      // --- Build lookup of videos by ymd ---
      const videoByYmd = {};
      if (videoMeta && Array.isArray(videoMeta.videos)) {
        for (const v of videoMeta.videos) {
          const key = String(v.ymd);
          videoByYmd[key] = v;
        }
      }
      console.log("Video entries by day:", Object.keys(videoByYmd));

      // --- Global hour range from meta ---
      const rawH0 = keogramMeta.global_h0 ?? keogramMeta.global_min_hour ?? 0;
      const rawH1 = keogramMeta.global_h1 ?? keogramMeta.global_max_hour ?? 24;

      let globalH0 = Number(rawH0);
      let globalH1 = Number(rawH1);

      console.log(
        "Global hour range from meta (raw):",
        rawH0,
        rawH1,
        " -> parsed:",
        globalH0,
        globalH1
      );

      if (!Number.isFinite(globalH0) || !Number.isFinite(globalH1) || globalH0 >= globalH1) {
        console.warn("Global hour values invalid; defaulting to 0–24.");
        globalH0 = 0;
        globalH1 = 24;
      }

      const days    = keogramMeta.days;
      const numRows = days.length;

      // ---------------- CLICK HANDLER ----------------
      function handleClick(ev) {
        const rect   = img.getBoundingClientRect();
        const clickX = ev.clientX - rect.left;
        const clickY = ev.clientY - rect.top;

        const relX = clickX / rect.width;   // 0..1 time
        const relY = clickY / rect.height;  // 0..1 stacked days

        // Map Y to row index (nearest row center)
        let rowFloat = relY * numRows;
        let rowIndex = Math.round(rowFloat - 0.5);
        if (rowIndex < 0) rowIndex = 0;
        if (rowIndex >= numRows) rowIndex = numRows - 1;

        const dayEntry = days[rowIndex];
        const ymd      = String(dayEntry.ymd);

        console.log("Click mapping:", {
          clickX: clickX.toFixed(1),
          clickY: clickY.toFixed(1),
          relX: relX.toFixed(3),
          relY: relY.toFixed(3),
          rowFloat: rowFloat.toFixed(3),
          rowIndex,
          ymd
        });

        if (!/^\d{8}$/.test(ymd)) {
          console.error("Bad ymd format:", ymd);
          alert("Internal error: bad date code " + ymd);
          return;
        }

        // X → UT using globalH0/globalH1
        const fracHour      = globalH0 + relX * (globalH1 - globalH0);
        const hourInt       = Math.floor(fracHour);
        const minutesFloat  = (fracHour - hourInt) * 60;
        const minuteInt     = Math.floor(minutesFloat);
        const secondsFloat  = (minutesFloat - minuteInt) * 60;
        let   secondInt     = Math.round(secondsFloat);

        let h = hourInt;
        let m = minuteInt;
        let s = secondInt;

        if (s >= 60) {
          s -= 60;
          m += 1;
        }
        if (m >= 60) {
          m -= 60;
          h += 1;
        }

        const year     = parseInt(ymd.slice(0, 4), 10);
        const monthIdx = parseInt(ymd.slice(4, 6), 10) - 1; // JS months 0–11
        const day      = parseInt(ymd.slice(6, 8), 10);

        const clickMs = Date.UTC(year, monthIdx, day, h, m, s);
        if (!Number.isFinite(clickMs)) {
          console.error("Invalid clickMs from date pieces:", { year, monthIdx, day, h, m, s });
          alert("Internal error computing click time – see console.");
          return;
        }

        // --- Video metadata for that day ---
        const vid = videoByYmd[ymd];
        if (!vid) {
          console.warn("No video entry for day", ymd);
          alert("No video available for this day (" + ymd + ").");
          return;
        }

        const videoStartMs = Date.parse(vid.start_utc);
        const videoEndMs   = Date.parse(vid.end_utc);
        if (!Number.isFinite(videoStartMs) || !Number.isFinite(videoEndMs) || videoEndMs <= videoStartMs) {
          console.error("Bad video timestamps for", ymd, vid);
          alert("Video metadata for " + ymd + " is incomplete.");
          return;
        }

        const realSpanMs = videoEndMs - videoStartMs;

        // 30-minute UT window centered on click
        const HALF_WINDOW_MIN = 15;
        let windowStartMs = clickMs - HALF_WINDOW_MIN * 60 * 1000;
        let windowEndMs   = clickMs + HALF_WINDOW_MIN * 60 * 1000;

        // Clamp to video coverage
        if (windowStartMs < videoStartMs) windowStartMs = videoStartMs;
        if (windowEndMs > videoEndMs)     windowEndMs   = videoEndMs;
        if (windowEndMs < windowStartMs)  windowEndMs   = windowStartMs;

        // Normalize positions within full video span
        const startRawPos  = (windowStartMs - videoStartMs) / realSpanMs;
        const endRawPos    = (windowEndMs   - videoStartMs) / realSpanMs;
        const startNormPos = Math.min(1, Math.max(0, startRawPos));
        const endNormPos   = Math.min(1, Math.max(0, endRawPos));

        const clickIso    = new Date(clickMs).toISOString();
        const winStartIso = new Date(windowStartMs).toISOString();
        const winEndIso   = new Date(windowEndMs).toISOString();
        const startIso    = new Date(videoStartMs).toISOString();
        const endIso      = new Date(videoEndMs).toISOString();

        console.log("Time mapping (window):", {
          ymd,
          clickIso,
          winStartIso,
          winEndIso,
          startIso,
          endIso,
          realSpanSec: realSpanMs / 1000,
          startNormPos,
          endNormPos
        });

        // Display clicked UT in info box
        const clickDate = new Date(clickMs);
        const HH = clickDate.getUTCHours().toString().padStart(2, "0");
        const MM = clickDate.getUTCMinutes().toString().padStart(2, "0");
        const SS = clickDate.getUTCSeconds().toString().padStart(2, "0");

        infoBox.textContent =
          "Day " + ymd +
          " | clicked UT ≈ " + HH + ":" + MM + ":" + SS +
          "\nVideo: " + vid.video_file +
          "\nWindow ≈ [ " + winStartIso + "  →  " + winEndIso + " ] (UT, ~" +
          (2 * HALF_WINDOW_MIN) + " min span).";

        const videoUrl = videoBase + vid.video_file;

        // Use hidden <video> to read full duration, then open new tab with #t=start,end
        player.pause();
        player.removeAttribute("src");
        player.load();

        player.src = videoUrl;
        player.load();

        player.onloadedmetadata = () => {
          const duration = player.duration;

          let startSec = 0;
          let endSec   = duration;

          if (Number.isFinite(duration) && duration > 0) {
            startSec = startNormPos * duration;
            endSec   = endNormPos   * duration;

            // Ensure at least a tiny span
            if (endSec < startSec + 0.5) {
              endSec = Math.min(duration, startSec + 0.5);
            }
          }

          console.log("Video metadata loaded for #t fragment:", {
            duration,
            startNormPos,
            endNormPos,
            startSec,
            endSec
          });

          const openUrl =
            videoUrl +
            "#t=" +
            startSec.toFixed(1) + "," +
            endSec.toFixed(1);

          window.open(openUrl, "_blank");
        };
      }

      // ---------------- HOVER HANDLER ----------------
      function handleMouseMove(ev) {
        const rect = img.getBoundingClientRect();
        const x    = ev.clientX - rect.left;
        const y    = ev.clientY - rect.top;

        const relX = x / rect.width;
        const relY = y / rect.height;

        // Map Y to row index (same as click)
        let rowFloat = relY * numRows;
        let rowIndex = Math.round(rowFloat - 0.5);
        if (rowIndex < 0) rowIndex = 0;
        if (rowIndex >= numRows) rowIndex = numRows - 1;

        const dayEntry = days[rowIndex];
        const ymd      = String(dayEntry.ymd);
        if (!/^\d{8}$/.test(ymd)) {
          return;
        }

        // X → UT using global hour range
        const fracHour      = globalH0 + relX * (globalH1 - globalH0);
        const hourInt       = Math.floor(fracHour);
        const minutesFloat  = (fracHour - hourInt) * 60;
        const minuteInt     = Math.floor(minutesFloat);
        const secondsFloat  = (minutesFloat - minuteInt) * 60;
        let   secondInt     = Math.round(secondsFloat);

        let h = hourInt;
        let m = minuteInt;
        let s = secondInt;

        if (s >= 60) {
          s -= 60;
          m += 1;
        }
        if (m >= 60) {
          m -= 60;
          h += 1;
        }

        const year     = parseInt(ymd.slice(0, 4), 10);
        const monthIdx = parseInt(ymd.slice(4, 6), 10) - 1;
        const day      = parseInt(ymd.slice(6, 8), 10);

        const hoverMs   = Date.UTC(year, monthIdx, day, h, m, s);
        const hoverDate = new Date(hoverMs);

        const Y  = hoverDate.getUTCFullYear();
        const M  = (hoverDate.getUTCMonth() + 1).toString().padStart(2, "0");
        const D  = hoverDate.getUTCDate().toString().padStart(2, "0");
        const HH = hoverDate.getUTCHours().toString().padStart(2, "0");
        const MM = hoverDate.getUTCMinutes().toString().padStart(2, "0");
        const SS = hoverDate.getUTCSeconds().toString().padStart(2, "0");

        const label = `${Y}-${M}-${D} ${HH}:${MM}:${SS} UT`;

        tooltip.textContent   = label;
        tooltip.style.left    = `${ev.pageX}px`;
        tooltip.style.top     = `${ev.pageY}px`;
        tooltip.style.opacity = "1";
      }

      function initAfterImageLoads() {
        img.addEventListener("click", handleClick);
        img.addEventListener("mousemove", handleMouseMove);
        img.addEventListener("mouseleave", () => {
          tooltip.style.opacity = "0";
        });
      }

      if (img.complete) {
        initAfterImageLoads();
      } else {
        img.addEventListener("load", initAfterImageLoads);
      }

      console.log("Keogram interactive init complete.");
    }
 
    init();

  </script>
</body>
</html>
